From: Jan Beich <jbeich@FreeBSD.org>
Date: Fri, 12 Oct 2018 12:56:00 -0400
Subject: Bug 1376873 - Unbreak WebRTC 64 build on BSDs. r=dminor f=gaston

Also includes:
Bug 1554949 - Fix WebRTC build failure with newer linux kernel. r=dminor

Mercurial Revision: https://hg.mozilla.org/mozilla-central/rev/a636ecdcb91afb1c5d436bbcbd87da4f10f7df78
---
 modules/video_capture/linux/device_info_v4l2.cc | 8 +++++++-
 rtc_base/byte_order.h                           | 2 ++
 rtc_base/cpu_info.cc                            | 2 +-
 rtc_base/physical_socket_server.cc              | 7 +++++--
 4 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/modules/video_capture/linux/device_info_v4l2.cc b/modules/video_capture/linux/device_info_v4l2.cc
index 6452a3c235..9f7f3ea508 100644
--- a/modules/video_capture/linux/device_info_v4l2.cc
+++ b/modules/video_capture/linux/device_info_v4l2.cc
@@ -11,7 +11,13 @@
 #include "modules/video_capture/linux/device_info_v4l2.h"
 
 #include <fcntl.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__) // WEBRTC_BSD
+#include <sys/videoio.h>
+#elif defined(__sun)
+#include <sys/videodev2.h>
+#else
 #include <linux/videodev2.h>
+#endif
 #include <sys/ioctl.h>
 #include <unistd.h>
 
@@ -209,8 +215,8 @@ DeviceInfoV4l2::DeviceInfoV4l2() : DeviceInfoImpl()
     {
         _inotifyEventThread->Start();
     }
-}
 #endif
+}
 
 int32_t DeviceInfoV4l2::Init() {
   return 0;
diff --git a/rtc_base/byte_order.h b/rtc_base/byte_order.h
index ba58571aca..dddaf9600b 100644
--- a/rtc_base/byte_order.h
+++ b/rtc_base/byte_order.h
@@ -90,6 +90,8 @@
 #error WEBRTC_ARCH_BIG_ENDIAN or WEBRTC_ARCH_LITTLE_ENDIAN must be defined.
 #endif  // defined(WEBRTC_ARCH_LITTLE_ENDIAN)
 
+#elif defined(WEBRTC_BSD) && !defined(__OpenBSD__)
+#include <sys/endian.h>
 #elif defined(WEBRTC_POSIX)
 #include <endian.h>
 #else
diff --git a/rtc_base/cpu_info.cc b/rtc_base/cpu_info.cc
index 22f76416b6..79505f20b4 100644
--- a/rtc_base/cpu_info.cc
+++ b/rtc_base/cpu_info.cc
@@ -66,7 +66,7 @@ uint32_t DetectNumberOfCores() {
   SYSTEM_INFO si;
   GetNativeSystemInfo(&si);
   number_of_cores = static_cast<int>(si.dwNumberOfProcessors);
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_ANDROID)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_ANDROID) || defined(WEBRTC_BSD)
   number_of_cores = static_cast<int>(sysconf(_SC_NPROCESSORS_ONLN));
   if (number_of_cores <= 0) {
     RTC_LOG(LS_ERROR) << "Failed to get number of cores";
diff --git a/rtc_base/physical_socket_server.cc b/rtc_base/physical_socket_server.cc
index 8a2f3f2185..ae982fcc08 100644
--- a/rtc_base/physical_socket_server.cc
+++ b/rtc_base/physical_socket_server.cc
@@ -80,7 +80,10 @@
 typedef void* SockOptArg;
 #endif  // WEBRTC_POSIX
 
-#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(__native_client__)
+#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(WEBRTC_BSD) && !defined(__native_client__)
+#if defined(WEBRTC_LINUX)
+#include <linux/sockios.h>
+#endif
 int64_t GetSocketRecvTimestamp(int socket) {
   struct timeval tv_ioctl;
   int ret = ioctl(socket, SIOCGSTAMP, &tv_ioctl);
@@ -700,7 +703,7 @@ int PhysicalSocket::TranslateOption(Option opt, int* slevel, int* sopt) {
       *slevel = IPPROTO_IP;
       *sopt = IP_DONTFRAGMENT;
       break;
-#elif defined(WEBRTC_MAC) || defined(BSD) || defined(__native_client__)
+#elif defined(WEBRTC_MAC) || defined(WEBRTC_BSD) || defined(__native_client__)
       RTC_LOG(LS_WARNING) << "Socket::OPT_DONTFRAGMENT not supported.";
       return -1;
 #elif defined(WEBRTC_POSIX)
